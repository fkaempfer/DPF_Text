/*
 * generated by Xtext
 */
package no.hib.dpf.text.serializer;

import com.google.inject.Inject;
import com.google.inject.Provider;
import no.hib.dpf.text.services.DPFTextGrammarAccess;
import no.hib.dpf.text.tdpf.Arrow;
import no.hib.dpf.text.tdpf.AttributeValue;
import no.hib.dpf.text.tdpf.Batch;
import no.hib.dpf.text.tdpf.ChoosenSignature;
import no.hib.dpf.text.tdpf.ChoosenSpecification;
import no.hib.dpf.text.tdpf.Constraint;
import no.hib.dpf.text.tdpf.ConstraintList;
import no.hib.dpf.text.tdpf.DpfId;
import no.hib.dpf.text.tdpf.Graph;
import no.hib.dpf.text.tdpf.MakeDiagram;
import no.hib.dpf.text.tdpf.MakeEcore;
import no.hib.dpf.text.tdpf.MakeEmf;
import no.hib.dpf.text.tdpf.MakeImage;
import no.hib.dpf.text.tdpf.Node;
import no.hib.dpf.text.tdpf.NodeSimple;
import no.hib.dpf.text.tdpf.Property;
import no.hib.dpf.text.tdpf.RId;
import no.hib.dpf.text.tdpf.Signature;
import no.hib.dpf.text.tdpf.Specification;
import no.hib.dpf.text.tdpf.TdpfPackage;
import no.hib.dpf.text.tdpf.TestMatch;
import no.hib.dpf.text.tdpf.Validator;
import no.hib.dpf.text.tdpf.Version;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.serializer.acceptor.ISemanticSequenceAcceptor;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.diagnostic.ISemanticSequencerDiagnosticProvider;
import org.eclipse.xtext.serializer.diagnostic.ISerializationDiagnostic.Acceptor;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.GenericSequencer;
import org.eclipse.xtext.serializer.sequencer.ISemanticNodeProvider.INodesForEObjectProvider;
import org.eclipse.xtext.serializer.sequencer.ISemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public abstract class AbstractDPFTextSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private DPFTextGrammarAccess grammarAccess;
	
	@Override
	public void createSequence(EObject context, EObject semanticObject) {
		if(semanticObject.eClass().getEPackage() == TdpfPackage.eINSTANCE) switch(semanticObject.eClass().getClassifierID()) {
			case TdpfPackage.ARROW:
				sequence_Arrow(context, (Arrow) semanticObject); 
				return; 
			case TdpfPackage.ATTRIBUTE_VALUE:
				sequence_AttributeValue(context, (AttributeValue) semanticObject); 
				return; 
			case TdpfPackage.BATCH:
				sequence_Batch(context, (Batch) semanticObject); 
				return; 
			case TdpfPackage.CHOOSEN_SIGNATURE:
				sequence_ChoosenSignature(context, (ChoosenSignature) semanticObject); 
				return; 
			case TdpfPackage.CHOOSEN_SPECIFICATION:
				sequence_ChoosenSpecification(context, (ChoosenSpecification) semanticObject); 
				return; 
			case TdpfPackage.CONSTRAINT:
				sequence_Constraint(context, (Constraint) semanticObject); 
				return; 
			case TdpfPackage.CONSTRAINT_LIST:
				sequence_ConstraintList(context, (ConstraintList) semanticObject); 
				return; 
			case TdpfPackage.DPF_ID:
				sequence_DpfId(context, (DpfId) semanticObject); 
				return; 
			case TdpfPackage.GRAPH:
				sequence_Graph(context, (Graph) semanticObject); 
				return; 
			case TdpfPackage.MAKE_DIAGRAM:
				sequence_MakeDiagram(context, (MakeDiagram) semanticObject); 
				return; 
			case TdpfPackage.MAKE_ECORE:
				sequence_MakeEcore(context, (MakeEcore) semanticObject); 
				return; 
			case TdpfPackage.MAKE_EMF:
				sequence_MakeEmf(context, (MakeEmf) semanticObject); 
				return; 
			case TdpfPackage.MAKE_IMAGE:
				sequence_MakeImage(context, (MakeImage) semanticObject); 
				return; 
			case TdpfPackage.NODE:
				sequence_Node(context, (Node) semanticObject); 
				return; 
			case TdpfPackage.NODE_SIMPLE:
				sequence_NodeSimple(context, (NodeSimple) semanticObject); 
				return; 
			case TdpfPackage.PROPERTY:
				sequence_Property(context, (Property) semanticObject); 
				return; 
			case TdpfPackage.RID:
				sequence_RId(context, (RId) semanticObject); 
				return; 
			case TdpfPackage.SIGNATURE:
				sequence_Signature(context, (Signature) semanticObject); 
				return; 
			case TdpfPackage.SPECIFICATION:
				sequence_Specification(context, (Specification) semanticObject); 
				return; 
			case TdpfPackage.TEST_MATCH:
				sequence_TestMatch(context, (TestMatch) semanticObject); 
				return; 
			case TdpfPackage.VALIDATOR:
				sequence_Validator(context, (Validator) semanticObject); 
				return; 
			case TdpfPackage.VERSION:
				sequence_Version(context, (Version) semanticObject); 
				return; 
			}
		if (errorAcceptor != null) errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Constraint:
	 *     (
	 *         (sr=NodeSimple id=DpfId tgDataType=DataType) | 
	 *         (sr=NodeSimple id=DpfId type=DpfId tgValue=AttributeValue) | 
	 *         (sr=NodeSimple id=DpfId type=DpfId tgNode=NodeSimple) | 
	 *         (sr=NodeSimple tgNode=NodeSimple)
	 *     )
	 */
	protected void sequence_Arrow(EObject context, Arrow semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (value=STRING | variableId=ID)
	 */
	protected void sequence_AttributeValue(EObject context, AttributeValue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (commands+=Command commands+=Command*)
	 */
	protected void sequence_Batch(EObject context, Batch semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (id=ID versionName=STRING)
	 */
	protected void sequence_ChoosenSignature(EObject context, ChoosenSignature semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, TdpfPackage.Literals.CHOOSEN_SIGNATURE__ID) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TdpfPackage.Literals.CHOOSEN_SIGNATURE__ID));
			if(transientValues.isValueTransient(semanticObject, TdpfPackage.Literals.CHOOSEN_SIGNATURE__VERSION_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TdpfPackage.Literals.CHOOSEN_SIGNATURE__VERSION_NAME));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getChoosenSignatureAccess().getIdIDTerminalRuleCall_0_0(), semanticObject.getId());
		feeder.accept(grammarAccess.getChoosenSignatureAccess().getVersionNameSTRINGTerminalRuleCall_2_0(), semanticObject.getVersionName());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (id=ID versionName=STRING)
	 */
	protected void sequence_ChoosenSpecification(EObject context, ChoosenSpecification semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, TdpfPackage.Literals.CHOOSEN_SPECIFICATION__ID) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TdpfPackage.Literals.CHOOSEN_SPECIFICATION__ID));
			if(transientValues.isValueTransient(semanticObject, TdpfPackage.Literals.CHOOSEN_SPECIFICATION__VERSION_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TdpfPackage.Literals.CHOOSEN_SPECIFICATION__VERSION_NAME));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getChoosenSpecificationAccess().getIdIDTerminalRuleCall_0_0(), semanticObject.getId());
		feeder.accept(grammarAccess.getChoosenSpecificationAccess().getVersionNameSTRINGTerminalRuleCall_2_0(), semanticObject.getVersionName());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (constraintSemantic=ChoosenSignature (constraints+=Constraint constraints+=Constraint*)?)
	 */
	protected void sequence_ConstraintList(EObject context, ConstraintList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (type=DpfId (parameter+=STRING parameter+=STRING*)? (arity_d+=Arrow | arity_d+=NodeSimple) (arity_d+=Arrow | arity_d+=NodeSimple)*)
	 */
	protected void sequence_Constraint(EObject context, Constraint semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID id=RId?)
	 */
	protected void sequence_DpfId(EObject context, DpfId semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (elements+=Element elements+=Element*)?
	 */
	protected void sequence_Graph(EObject context, Graph semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (id=ID type=GraphvizOutput?)
	 */
	protected void sequence_MakeDiagram(EObject context, MakeDiagram semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     id=ID
	 */
	protected void sequence_MakeEcore(EObject context, MakeEcore semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, TdpfPackage.Literals.MAKE_ECORE__ID) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TdpfPackage.Literals.MAKE_ECORE__ID));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getMakeEcoreAccess().getIdIDTerminalRuleCall_2_0(), semanticObject.getId());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     id=ID
	 */
	protected void sequence_MakeEmf(EObject context, MakeEmf semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, TdpfPackage.Literals.MAKE_EMF__ID) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TdpfPackage.Literals.MAKE_EMF__ID));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getMakeEmfAccess().getIdIDTerminalRuleCall_2_0(), semanticObject.getId());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (id=ID type=GraphvizOutput?)
	 */
	protected void sequence_MakeImage(EObject context, MakeImage semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (id=DpfId type=DpfId)
	 */
	protected void sequence_NodeSimple(EObject context, NodeSimple semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, TdpfPackage.Literals.NODE_SIMPLE__ID) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TdpfPackage.Literals.NODE_SIMPLE__ID));
			if(transientValues.isValueTransient(semanticObject, TdpfPackage.Literals.NODE_SIMPLE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TdpfPackage.Literals.NODE_SIMPLE__TYPE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getNodeSimpleAccess().getIdDpfIdParserRuleCall_0_0(), semanticObject.getId());
		feeder.accept(grammarAccess.getNodeSimpleAccess().getTypeDpfIdParserRuleCall_2_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (id=DpfId type=DpfId (inh+=NodeSimple inh+=NodeSimple*)? (properties+=Property properties+=Property*)?)
	 */
	protected void sequence_Node(EObject context, Node semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     ((id=DpfId tgDataType=DataType) | (id=DpfId type=DpfId tgValue=AttributeValue) | (id=DpfId type=DpfId tgNode=NodeSimple))
	 */
	protected void sequence_Property(EObject context, Property semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (nums+=INT nums+=INT*)
	 */
	protected void sequence_RId(EObject context, RId semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (version=Version input=ConstraintLanguage? validators+=Validator validators+=Validator*)
	 */
	protected void sequence_Signature(EObject context, Signature semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (version=Version type=ChoosenSpecification output='<PLAIN>'? graph=Graph atomicConstraints+=ConstraintList*)
	 */
	protected void sequence_Specification(EObject context, Specification semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (search=ID into=ID)
	 */
	protected void sequence_TestMatch(EObject context, TestMatch semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, TdpfPackage.Literals.TEST_MATCH__SEARCH) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TdpfPackage.Literals.TEST_MATCH__SEARCH));
			if(transientValues.isValueTransient(semanticObject, TdpfPackage.Literals.TEST_MATCH__INTO) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TdpfPackage.Literals.TEST_MATCH__INTO));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getTestMatchAccess().getSearchIDTerminalRuleCall_2_0(), semanticObject.getSearch());
		feeder.accept(grammarAccess.getTestMatchAccess().getIntoIDTerminalRuleCall_4_0(), semanticObject.getInto());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         id=DpfId 
	 *         (parameter_vars+=ID parameter_vars+=ID*)? 
	 *         (arity+=Arrow | arity+=NodeSimple) 
	 *         (arity+=Arrow | arity+=NodeSimple)* 
	 *         ocl=STRING 
	 *         errorMsg=STRING
	 *     )
	 */
	protected void sequence_Validator(EObject context, Validator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=STRING number=INT nextNumber=INT)
	 */
	protected void sequence_Version(EObject context, Version semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, TdpfPackage.Literals.VERSION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TdpfPackage.Literals.VERSION__NAME));
			if(transientValues.isValueTransient(semanticObject, TdpfPackage.Literals.VERSION__NUMBER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TdpfPackage.Literals.VERSION__NUMBER));
			if(transientValues.isValueTransient(semanticObject, TdpfPackage.Literals.VERSION__NEXT_NUMBER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TdpfPackage.Literals.VERSION__NEXT_NUMBER));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getVersionAccess().getNameSTRINGTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getVersionAccess().getNumberINTTerminalRuleCall_3_0(), semanticObject.getNumber());
		feeder.accept(grammarAccess.getVersionAccess().getNextNumberINTTerminalRuleCall_5_0(), semanticObject.getNextNumber());
		feeder.finish();
	}
}
